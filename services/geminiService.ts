
import { TableData, ColumnType, Column } from "../types";

/**
 * 로컬 로직을 사용하여 현재 스키마 상태를 기반으로 PostgreSQL DDL SQL을 생성합니다.
 */
export const generateSQL = (tables: TableData[], relations: any[]): string => {
  let sql = `-- Generated by TableMaker (Local Export)\n-- Target: PostgreSQL\n-- Generated at: ${new Date().toLocaleString()}\n\n`;

  // 1. Create Tables
  tables.forEach(table => {
    sql += `CREATE TABLE "${table.name}" (\n`;
    
    const columnDefinitions = table.columns.map(col => {
      let line = `  "${col.name}" ${mapDataType(col.type)}`;
      
      if (col.isPK) line += ` PRIMARY KEY`;
      if (col.isUnique && !col.isPK) line += ` UNIQUE`;
      if (!col.isNullable) line += ` NOT NULL`;
      
      return line;
    });
    
    sql += columnDefinitions.join(',\n');
    sql += `\n);\n\n`;
  });

  // 2. Add Foreign Key Constraints
  relations.forEach((rel, index) => {
    const sourceTable = tables.find(t => t.id === rel.source);
    const targetTable = tables.find(t => t.id === rel.target);
    
    if (sourceTable && targetTable && rel.sourceHandle && rel.targetHandle) {
      const sourceCol = sourceTable.columns.find(c => c.id === rel.sourceHandle);
      const targetCol = targetTable.columns.find(c => c.id === rel.targetHandle);
      
      if (sourceCol && targetCol) {
        const fkName = `fk_${targetTable.name}_${targetCol.name}_${index}`;
        sql += `ALTER TABLE "${targetTable.name}" \n  ADD CONSTRAINT "${fkName}" \n  FOREIGN KEY ("${targetCol.name}") \n  REFERENCES "${sourceTable.name}" ("${sourceCol.name}");\n\n`;
      }
    }
  });

  return sql;
};

/**
 * SQL DDL을 파싱하여 앱 데이터 구조로 변환합니다.
 */
export const parseSQL = (sql: string): { tables: TableData[], relations: any[] } => {
  const tables: TableData[] = [];
  const relations: any[] = [];
  
  // Normalize SQL
  const cleanSql = sql.replace(/--.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '');
  
  // 1. Parse CREATE TABLE
  const createTableRegex = /CREATE\s+TABLE\s+(?:"?([^"\s\(\)]+)"?)\s*\(([\s\S]*?)\);/gi;
  let match;
  
  while ((match = createTableRegex.exec(cleanSql)) !== null) {
    const tableName = match[1];
    const columnsText = match[2];
    const tableId = `t-${Math.random().toString(36).substr(2, 9)}`;
    
    const columns: Column[] = [];
    const colLines = columnsText.split(/,(?![^(]*\))/); // Split by comma not inside brackets
    
    colLines.forEach(line => {
      const colMatch = /"([^"]+)"\s+([A-Z]+(?:\(\d+\))?)(.*)/i.exec(line.trim());
      if (colMatch) {
        const colName = colMatch[1];
        const rawType = colMatch[2].toUpperCase();
        const constraints = colMatch[3].toUpperCase();
        
        columns.push({
          id: `c-${Math.random().toString(36).substr(2, 9)}`,
          name: colName,
          type: reverseMapDataType(rawType),
          isPK: constraints.includes('PRIMARY KEY'),
          isFK: false, // Initially false, updated by relations later
          isUnique: constraints.includes('UNIQUE'),
          isNullable: !constraints.includes('NOT NULL')
        });
      }
    });
    
    tables.push({ id: tableId, name: tableName, columns });
  }
  
  // 2. Parse ALTER TABLE for Foreign Keys
  const fkRegex = /ALTER\s+TABLE\s+(?:"?([^"\s]+)"?)\s+ADD\s+CONSTRAINT\s+(?:"?[^"\s]+"?)?\s*FOREIGN\s+KEY\s*\((?:"?([^"\s]+)"?)\)\s+REFERENCES\s+(?:"?([^"\s]+)"?)\s*\((?:"?([^"\s]+)"?)\)/gi;
  
  while ((match = fkRegex.exec(cleanSql)) !== null) {
    const targetTableName = match[1];
    const targetColName = match[2];
    const sourceTableName = match[3];
    const sourceColName = match[4];
    
    const sourceTable = tables.find(t => t.name === sourceTableName);
    const targetTable = tables.find(t => t.name === targetTableName);
    
    if (sourceTable && targetTable) {
      const sourceCol = sourceTable.columns.find(c => c.name === sourceColName);
      const targetCol = targetTable.columns.find(c => c.name === targetColName);
      
      if (sourceCol && targetCol) {
        targetCol.isFK = true;
        relations.push({
          source: sourceTable.id,
          target: targetTable.id,
          sourceHandle: sourceCol.id,
          targetHandle: targetCol.id,
          label: '1:N'
        });
      }
    }
  }
  
  return { tables, relations };
};

// Helper to map UI types to SQL types
const mapDataType = (type: ColumnType): string => {
  switch (type) {
    case 'VARCHAR': return 'VARCHAR(255)';
    case 'INTEGER': return 'INTEGER';
    case 'BOOLEAN': return 'BOOLEAN';
    case 'DATE': return 'DATE';
    case 'TIMESTAMP': return 'TIMESTAMP';
    case 'UUID': return 'UUID';
    case 'TEXT': return 'TEXT';
    case 'JSON': return 'JSONB';
    default: return 'VARCHAR(255)';
  }
};

const reverseMapDataType = (rawType: string): ColumnType => {
  if (rawType.includes('VARCHAR')) return 'VARCHAR';
  if (rawType.includes('INT')) return 'INTEGER';
  if (rawType.includes('BOOL')) return 'BOOLEAN';
  if (rawType.includes('DATE')) return 'DATE';
  if (rawType.includes('TIMESTAMP')) return 'TIMESTAMP';
  if (rawType.includes('UUID')) return 'UUID';
  if (rawType.includes('TEXT')) return 'TEXT';
  if (rawType.includes('JSON')) return 'JSON';
  return 'VARCHAR';
};
