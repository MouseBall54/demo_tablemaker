
import { TableData, ColumnType, Column } from "../types";

/**
 * 로컬 로직을 사용하여 현재 스키마 상태를 기반으로 PostgreSQL DDL SQL을 생성합니다.
 */
export const generateSQL = (tables: TableData[], relations: any[]): string => {
  let sql = `-- Generated by TableMaker (Local Export)\n-- Target: PostgreSQL\n-- Generated at: ${new Date().toLocaleString()}\n\n`;

  // 1. Create Tables
  tables.forEach(table => {
    sql += `CREATE TABLE "${table.name}" (\n`;
    
    const columnDefinitions = table.columns.map(col => {
      let line = `  "${col.name}" ${mapDataType(col.type)}`;
      
      if (col.isPK) line += ` PRIMARY KEY`;
      if (col.isUnique && !col.isPK) line += ` UNIQUE`;
      if (!col.isNullable) line += ` NOT NULL`;
      
      return line;
    });
    
    sql += columnDefinitions.join(',\n');
    sql += `\n);\n\n`;
  });

  // 2. Add Foreign Key Constraints
  relations.forEach((rel, index) => {
    const sourceTable = tables.find(t => t.id === rel.source);
    const targetTable = tables.find(t => t.id === rel.target);
    
    if (sourceTable && targetTable && rel.sourceHandle && rel.targetHandle) {
      const sourceCol = sourceTable.columns.find(c => c.id === rel.sourceHandle);
      const targetCol = targetTable.columns.find(c => c.id === rel.targetHandle);
      
      if (sourceCol && targetCol) {
        const fkName = `fk_${targetTable.name}_${targetCol.name}_${index}`;
        sql += `ALTER TABLE "${targetTable.name}" \n  ADD CONSTRAINT "${fkName}" \n  FOREIGN KEY ("${targetCol.name}") \n  REFERENCES "${sourceTable.name}" ("${sourceCol.name}");\n\n`;
      }
    }
  });

  return sql;
};

/**
 * SQL DDL을 파싱하여 앱 데이터 구조로 변환합니다.
 */
export const parseSQL = (sql: string): { tables: TableData[], relations: any[] } => {
  const tables: TableData[] = [];
  const relations: any[] = [];
  
  // 1. Pre-cleaning
  let cleanSql = sql
    .replace(/--.*$/gm, '') // Remove line comments
    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove block comments
    .replace(/DO\s*\$\$\s*[\s\S]*?\$\$\s*;/gi, '') // Remove DO $$ blocks
    .replace(/CREATE\s+(?:UNIQUE\s+)?INDEX[\s\S]*?;/gi, '') // Remove INDEX creation
    .trim();
  
  // 2. Parse CREATE TABLE
  const createTableRegex = /CREATE\s+TABLE\s+(?:"?([^"\s\(\)]+)"?)\s*\(([\s\S]*?)\);/gi;
  let tableMatch;
  
  while ((tableMatch = createTableRegex.exec(cleanSql)) !== null) {
    const tableName = tableMatch[1];
    const columnsText = tableMatch[2];
    const tableId = `t-${Math.random().toString(36).substr(2, 9)}`;
    
    const columns: Column[] = [];
    const colLines = columnsText.split(/,(?![^(]*\))/);
    
    colLines.forEach(line => {
      const trimmedLine = line.trim();
      if (!trimmedLine || 
          /^(?:PRIMARY\s+KEY|UNIQUE|CONSTRAINT|CHECK|FOREIGN\s+KEY)/i.test(trimmedLine)) {
        return;
      }

      // Match column name (quoted or not), type, and everything else
      const colMatch = /(?:"?([^"\s]+)"?)\s+([A-Z0-9_]+(?:\s*\([^)]+\))?)([\s\S]*)/i.exec(trimmedLine);
      
      if (colMatch) {
        const colName = colMatch[1];
        const rawType = colMatch[2].toUpperCase();
        const rest = colMatch[3]; // Keep original for reference matching
        
        const colId = `c-${Math.random().toString(36).substr(2, 9)}`;
        const column: Column = {
          id: colId,
          name: colName,
          type: reverseMapDataType(rawType),
          isPK: /PRIMARY\s+KEY/i.test(rest),
          isFK: /REFERENCES/i.test(rest),
          isUnique: /UNIQUE/i.test(rest),
          isNullable: !/NOT\s+NULL/i.test(rest)
        };
        
        columns.push(column);

        // Extract inline references: REFERENCES table(col)
        const inlineFkMatch = /REFERENCES\s+(?:"?([^"\s\(\)]+)"?)\s*\(\s*(?:"?([^"\s\(\)]+)"?)\s*\)/i.exec(rest);
        if (inlineFkMatch) {
          (column as any)._rawRefTable = inlineFkMatch[1];
          (column as any)._rawRefCol = inlineFkMatch[2];
        }
      }
    });
    
    tables.push({ id: tableId, name: tableName, columns });
  }
  
  // 3. Resolve Relationships
  
  // 3a. Inline References
  tables.forEach(targetTable => {
    targetTable.columns.forEach(targetCol => {
      const rawRefTable = (targetCol as any)._rawRefTable;
      const rawRefCol = (targetCol as any)._rawRefCol;
      
      if (rawRefTable) {
        // Case-insensitive search
        const sourceTable = tables.find(t => t.name.toLowerCase() === rawRefTable.toLowerCase());
        if (sourceTable) {
          const sourceCol = sourceTable.columns.find(c => c.name.toLowerCase() === rawRefCol.toLowerCase());
          if (sourceCol) {
            relations.push({
              source: sourceTable.id,
              target: targetTable.id,
              sourceHandle: sourceCol.id,
              targetHandle: targetCol.id,
              label: '1:N'
            });
          }
        }
      }
    });
  });

  // 3b. ALTER TABLE References
  const alterFkRegex = /ALTER\s+TABLE\s+(?:"?([^"\s]+)"?)\s+ADD\s+CONSTRAINT\s+(?:"?[^"\s]+"?)?\s*FOREIGN\s+KEY\s*\((?:"?([^"\s]+)"?)\)\s+REFERENCES\s+(?:"?([^"\s]+)"?)\s*\((?:"?([^"\s]+)"?)\)/gi;
  
  let alterFkMatch;
  while ((alterFkMatch = alterFkRegex.exec(cleanSql)) !== null) {
    const targetTableName = alterFkMatch[1];
    const targetColName = alterFkMatch[2];
    const sourceTableName = alterFkMatch[3];
    const sourceColName = alterFkMatch[4];
    
    const sourceTable = tables.find(t => t.name.toLowerCase() === sourceTableName.toLowerCase());
    const targetTable = tables.find(t => t.name.toLowerCase() === targetTableName.toLowerCase());
    
    if (sourceTable && targetTable) {
      const sourceCol = sourceTable.columns.find(c => c.name.toLowerCase() === sourceColName.toLowerCase());
      const targetCol = targetTable.columns.find(c => c.name.toLowerCase() === targetColName.toLowerCase());
      
      if (sourceCol && targetCol) {
        targetCol.isFK = true;
        const exists = relations.some(r => r.source === sourceTable.id && r.target === targetTable.id && r.sourceHandle === sourceCol.id && r.targetHandle === targetCol.id);
        if (!exists) {
          relations.push({
            source: sourceTable.id,
            target: targetTable.id,
            sourceHandle: sourceCol.id,
            targetHandle: targetCol.id,
            label: '1:N'
          });
        }
      }
    }
  }
  
  return { tables, relations };
};

// Helper to map UI types to SQL types
const mapDataType = (type: ColumnType): string => {
  switch (type) {
    case 'VARCHAR': return 'VARCHAR(255)';
    case 'INTEGER': return 'INTEGER';
    case 'BOOLEAN': return 'BOOLEAN';
    case 'DATE': return 'DATE';
    case 'TIMESTAMP': return 'TIMESTAMPTZ';
    case 'UUID': return 'UUID';
    case 'TEXT': return 'TEXT';
    case 'JSON': return 'JSONB';
    default: return 'VARCHAR(255)';
  }
};

const reverseMapDataType = (rawType: string): ColumnType => {
  const t = rawType.toUpperCase();
  if (t.includes('VARCHAR') || t.includes('CHAR')) return 'VARCHAR';
  if (t.includes('INT') || t.includes('SERIAL') || t.includes('DOUBLE') || t.includes('NUMERIC') || t.includes('DECIMAL') || t.includes('FLOAT')) return 'INTEGER';
  if (t.includes('BOOL')) return 'BOOLEAN';
  if (t.includes('DATE')) return 'DATE';
  if (t.includes('TIMESTAMP')) return 'TIMESTAMP';
  if (t.includes('UUID')) return 'UUID';
  if (t.includes('TEXT')) return 'TEXT';
  if (t.includes('JSON')) return 'JSON';
  return 'VARCHAR';
};
